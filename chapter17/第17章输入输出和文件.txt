17.1C++输入输出概述
17.1.1流和缓冲区
C++中吧输入和输出看做字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。流充当了程序和流源或流目标之间的桥梁，管理输入包含两步：
1.将流与输入去向的程序关联起来
2.将流与文件关联起来

使用缓冲区可以更高效的处理输入和输出。缓冲区是用作中介的内存块，是将信息的临时存储工具。

17.1.2流，缓冲区和iostream文件
iostream文件中包含一些专门设计用来实现管理流和缓冲区的类：
1.streambuf类为缓冲区提供内存，并提供了用于填充缓冲区，访问缓冲区内容，刷新缓冲区和管理缓冲区内存的类方法；
2.ios_base类表示流的一般特征，如是否可读取，是二进制流还是文本流等；
3.ios类基于ios_base，其中包括了一个指向streambuf对象的指针成员；
4.ostream类从ios类派生出来，提供了输出方法；
5.istream类从iOS类派生出来，提供了输入方法
6.iostream类是基于istream和ostream类，继承了输入方法和输出方法。

char窄字符，wchar_t宽字符。istream和ostream是char具体化的typedef，wistream和wostream是wchar_t具体化，wcout对象用于输出款字符流。

在程序中包含iostream文件将自动创建8个流对象（4个窄字符流，4个宽字符流）：
1.cin，wcin：标准输入流，默认情况下将关联到标准输入设备（键盘）；
2.cout，wcout：标准输出流，默认情况下将关联到标准输出设备（显示器）；
3.cerr,wcerr：标准错误流，默认情况将关联到标准输出设备（显示器），这个流没有配缓冲，将信息直接发送给屏幕
4.clog，wclog：标准错误流，默认情况将关联到标准输出设备（显示器），这个流被缓冲。

17.1.3重定向
操作系统都支持重定向，使得能够改变标准输入和标准输出。

17.2使用cout进行输出
17.2.1重载的<<运算符
<<运算符默认含义是按位左移运算符，在ostream类中重新定义了<<运算符将其重载为输出。在这种情况下，<<配称作插入运算符。
除了operator<<()函数外，ostream类还提供了put()方法和write()方法，前者用于显示字符，后者用于显示字符串。

17.2.3刷新输出缓冲区
可以使用控制符来强行进行刷新：控制符flush刷新缓冲区，控制符endl刷新缓冲区，并插入一个换行符。
事实上，控制符也是函数，例如可以直接调用flush()来刷新cout缓冲区

17.2.4用cout进行格式化
格式化值的方式：
1.对于char值，如果代表的是可打印字符，则将被作为一个字符显示在宽度为一个字符的字段中
2.对于数值整型，将以10进制反射显示在一个刚好容纳数值以负号的字段中
3.字符串被显示在宽度等于该字符串长度的字段中
4.对于浮点数，浮点类型被显示为6位，末尾的0不显示。如果档指数大于6或小于等于-5时，将使用科学计数法表示，字段宽度恰好容纳数字和负号。默认行为对应fprintf的%g占位符。

每个值的显示宽度都等于它的长度，因此必须显式地在值之间提供空格。

1.修改显示使用的计数系统
ios_base类存储了描述格式状态的信息，由于ios_base是ostream的间接基类，因此可以使用控制符控制显示时使用的计数系统。
使用dec，hex，oct控制符控制整数以十进制，十六进制，八进制显示。完成设置后，程序将以设置的形式打印整数值，直到将格式状态设置为其他选项为止。

2.调整字段宽度
可以使用width成员函数将长度不同的数字放到宽度相同的字段中，该方法的原型是：
int width();返回字段宽度的当前设置
int width(int i);将字段宽度设置为i个空格，并返回以前的字段宽度值。
width()方法只影响将显示的下一个项目，然后字段宽度将恢复到默认值。
c++将不会截短数据，如果长度不够，C++将增宽字段，以容纳该数据。

3.填充字符
在默认情况下，cout用空格填充字段中未被使用的部分，可以用fill（）来改变填充字符。新的填充字符一直有效，直到更改它为止。

4.设置浮点数的显示精度
浮点数精度取决于输出模式，在默认模式下，精度指的是显示的总位数。在定点模式和科学模式下，精度指的是小数点后面的位数。C++的默认精度是6位。
precision（）使得能够选择精度值。新的精度设置将一直有效，直到被重新设置。

5.打印末尾的0和小数点
ios_base类提供了一个setf()函数，能够控制多种格式化特性，还定义了多个常量，用于该函数的参数。
cout.setf(ios_base::showpoint);//能显示末尾小数点。使用默认的浮点格式时，还将导致末尾的0被显示出来。

6.setf()
setf()的第一个原型：
fmtflags setf(fmtflags);//fmtflags是bitmask类型的typedef名，用于存储格式标记。该名称是在ios_base类中定义的。
修改一直有效，直到被覆盖为止。
ios_base::boolalpha；//输入和输出bool值，可以为true和false
ios_base::showbase;//对于输出，使用C++基数前缀(0,0x)
ios_base::showpoint://显示末尾的小数点
ios_base::uppercase;//对于16进制输出，使用大写字母E表示
ios_base::showpos;//在正数前面加上+

第二个setf()原型接收两个参数，并返回以前的设置：
fmtflags setf(fmtflags,fmtflags);
用于设置有多位控制的格式选项，第一个参数包含所需设置的fmtflags值，第二个参数指出要清除第一个参数的那些位

调用setf()的效果可以通过unsetf（）消除，后者的原型如下：
void unsetf（fmtflags mask）；

8.头文件iomanip
c++在头文件iomanip中提供了其他的一些控制符，能够提供iostream设置格式的功能。
3个最常用的控制符分别是setprecision(),setfill()和setw(),分别用来设置精度，填充字符和字段宽度。由于他们都是控制符，所以可以用cout语句连接起来。

17.3使用cin进行输入
cin 对象将标准输入表示为字节流，cin对象根据接收值的变量类型，使用其方法将字符序列转换为所需的类型。
cin的使用：cin>>value_holder;//value_holder为存储输入的内存单元，可以是变量，引用，陪解除引用的指针，也可以是类或者结构的成员。cin接收输入的方式取决于value_holder的数据类型。
可以将hex，oct和dec控制符与cin一起使用，来指定将整数解释为十六进制，八进制，十进制的格式。

17.3.2流状态
流状态（iostate类型，而iostate是一种bitmask类型）有三种ios_base元素组成：eofbit,badbit或failbit。每个元素都是一位，可以是1或0.
流状态：
eofbit:如果到达文件尾部，则设置为1
badbit：如果流被破坏，则设置为1；例如，文件读取错误
failbit:如果输入操作未能读取预期的字符或输出操作没有写入预期的字符，则设置为1
goodbit：另一种表示0的方法。
good():如果流可以使用，则返回true
eof():如果eofbit被设置，则返回true
bad():如果badbit被设置，则返回true
fail():如果badbit或failbit被设置，则返回true
rdstate():返回流状态
exceptions();返回一个位掩码，指出哪些标记导致异常被引发
exceptions(iostate ex);设置哪些状态将导致clear()引发异常；如果ex是eofbit，则如果eofbit被设置，clear()将引发异常
clear(iostate s):将流状态设置为s；s的默认值为0（goodbit）；如果（restate()&exceptions()）!=0,则引发异常basic_ios::failure
setstate(iostate s):调用clear(rdstate()，s).将设置与s中设置的位对应的流状态位，其他流状态位保存不变

1.设置状态
clear()方法将状态设置为它的参数。而setstate()方法只影响其参数中已设置的位。
3.流状态的影响
设置流状态位有一个非重要的后果：流将对后面的输入或输出关闭，直到位被清除。

17.3.3其他istream类方法
get()和getline():
1.方法get(char &)和get（void）提供了不跳过空白的单字符输入功能；
2.函数get(char *,int,char)和getline(char*,int,char)在默认情况下读取整行而不是一个单词。
1.单字符输入
get()方法读取下一个输入字符，即使该字符是空格，制表符或换行符。
get(char &ch)将输入字符赋给其参数ch，返回值是指向istream对象的引用，在到达文件尾时返回false
get()将输入字符转换为整型（int）并将其返回。在到达文件尾时返回ＥＯＦ。

３.字符串输入：getline(),get()和ignore()
getline()和get()的原型：
istream & get(char *,int,char);
istream & get(char *,int);
istream & getline(char *,int,char);
istream & getline(char *,int);
第一个参数用于放置输入字符串的内存单元的地址。第二个参数比要读取的最大字符数大1，第三个参数指定用作分界符的字符，只有两个参数的版本经换行符用作分界符。上述函数都在读取最大数目的字符或遇到换行符后为止。
get()和getline()之间的主要区别在于：get()将换行符留在输入流中，接下来的输入操作首先将是换行符，而getline()抽取并丢弃输入流中换行符
ignore（）的原型：
istream & ignore(int n =1,int = EOF);
该函数接收两个参数：一个是数字，指定要读取的最大字符数；一个是字符，用作输入分界符。函数将丢弃接下来的n个字符或者知道到达第一个换行符。

17.3.4其他的istream方法
read():读取指定书目的字节，并将它们存储在指定的位置中，read()不会再输入后加上空值字符，因此不能将输入转换为字符串，最常用是与ostream write()相结合，完成文件输入输出
peek()：返回输入的下一个字符，但不能抽取输入流中字符，能够查看下一个字符。
gcount():返回最后一个非格式化抽取方法读取的字符数。意味着是有get(),getline(),ignore(),read()方法读取的，不是有抽取运算符(>>)读取的。
puback();将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。

17.4文件输入输出
17.4.1简单的文件I/O
要让程序写入文件：
1.创建一个ofstream对象来管理输出流；
2.将该对象与特定的文件管理起来；使用open()方法。
3.以使用cout的方式使用该对象，唯一的区别是输出将进入文件，而不是屏幕。
注意：以默认模式打开文件进行输出将自动把文件的长度截断为0，相当于删除已有的内容。
读取文件：
1.创建一个ifstream对象来管理输入流；
2.将该对象与特定的文件关联起来；
3.以使用cin的方式使用该对象。
当输入和输出流对象过期时，到文件的连接将自动关闭，也可以使用close()方法显式的关闭到文件的连接。关闭连接并不会删除流，而只是断开流到文件的连接，然而流管理装置仍被保留，可以将流重新连接到同一个文件或另一个文件。

17.4.2流状态检查和is_open()
较新的c++实现了一种更好的检查文件是否被打开的方法-is_open()方法；

17.4.4命令行处理技术
在UNIX和linux系统中计算文件包含的字数，可以在命令行提示符输入下面的命令：
wc report1 report2 report3;wc是程序名，report1，report2，report3是作为命令行参数传递给程序的文件名

17.4.5文件模式
文件模式描述的是文件将被如何使用：读，写，追加。将流与文件关联时，都可以提供指定文件模式的第二个参数。
ios_base类定义了一个openmode类型，用于表示模式，它是一个bitmask类型，可以选择iOS_base类中定义的多个常量来指定模式。
ios_base::in；打开文件，以便读取
ios_base::out;打开文件，以便写入
ios_base::ate;打开文件，并移到文件尾
ios_base::app;追加到文件尾
ios_base::trunc;如果文件存在，则截短文件
ios_base::binary；二进制文件

要以二进制格式（而不是文本格式）存储数据，可以使用write()成员函数，这种方法将内存中指定书目的字节复制到文件中

17.4.6随机存取
随机存取指的是直接移动到文件的任何位置，读取修改其中的数据。
fstream类中两个方法：seekg()和seekp();
seekg():将输入指针移到指定的文件位置，用于ifstream对象
seekp();将输出指针移到指定的文件位置，用于ofstream对象。
seekg()的原型：
basic_istream<charT,traits>& seekg(off_type,ios_base::seekdir);
basic_istream<charT,traits>& seekg(pos_type);
第一个原型定位到离第二个参数指定文件位置特定距离的位置，第二个原型定位到离文件开头特定距离的位置。
seekg()第一个参数：streamoff值用来度量相对于文件特定位置的偏移量
seek_dir参数：有3个可能的值，常量ios_base::beg值相对于文件开始处的偏移量，常量ios_base::cur相对于当前位置的偏移量；ios_base::end相对于文件末尾的偏移量。

检查文件指针的当前位置：对于输入流，可以使用tellg()方法，对于输出流，可以使用tellp()方法。都返回一个表示当前位置的streampos值（以字节为单位，从文件开始处算起）。
使用fstream对象来管理输入输出流，则tellg()和tellp()返回的值相同。
使用istream对象和ostream对象来管理输入输出流，则tellg()和tellp()将返回不同的值。

使用临时文件：
1.位临时文件制定第一个命名方案，cstdio中声明的tmpname()函数创建一个临时文件，常量L_tempname和TMP_MAX现在文件名包含的字符数以及在确保当前目录中不生成重复文件名的情况下tmpname（）可被调用的最多次数。

17.5内核格式化
iostream族支持程序与终端之间的I/O,而fstream族使用相同的接口提供程序和文件之间的I/O.sstream族使用相同的接口提供程序与string对象之间的I/O。
使用cout的ostream方法将格式化信息写到string对象，使用istream方法读取string对象中信息。读取string对象中的格式化信息或将格式化信息写入string对象中被称为内核格式化。

如果创建一个ostringstream对象，可以将信息写入到其中，可将用于cout的方法用于ostringstream对象。
格式化文本进入缓冲区，在需要的情况下，该对象将使用动态内存分配来增大缓冲区。ostringstream类有一个str()方法，该函数返回一个呗初始化为缓冲区内容的字符串对象。
使用str()方法可以冻结该对象，这样就不能将信息写入该对象中。


