13类的继承
13.1一个简单的基类
从一个类派生出另一个类是，原始类称为基类，继承类称为派生类。继承首先需要一个基类。
class RatedPlayer:public TableTennisPlayer{}
冒号指出RatedPlayer类的基类是TableTannisPlayer类。上述特殊的声明头表明TableTennisPlayer是一个公有基类，
称为公有派生。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，
但只能通过基类的公有和保护方法访问。

有关派生类构造函数的要点如下：
首先创建基类对象；
派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
派生类构造函数应初始化派生类新增的数据成员。

13.2继承：is-a关系
派生类和基类的关系是基于c++继承的底层模型。c++有3中继承方式：公有继承、保护继承和私有继承。

13.3多态公有继承
同一种方法的行为虽上下文而异，取决于调用改方法的对象。这种较复杂的行为成为多态。
两种重要的机制可以实现多态公有继承：
1.在派生类中重新定义基类的方法
2.使用虚方法。

如果在派生类中重新定义基类的方法，通常将基类的方法声明为虚的。这样程序将根据对象类型而不是引用或指针类型来选择方法版本。
在声明方法时使用关键字virtual，这些方法被称为虚方法。virtual只用于类声明的方法原型中，没有用于方法定义中.

13.4静态联编和动态联编
将源代码的函数调用解释为执行特定的函数代码块被称为函数名联编(binding)。
C/C++编译器在编译过程中完成的联编被称为静态联编（static binding）.
编译器在生成程序运行时选择正确的虚方法的代码，被称为动态联编（dynamic binding）.

13.4.1指针和引用类型的兼容性
在c++中，动态联编与通过指针和引用调用方法有关。由继承控制。通常c++不允许将一种类型的地址赋给另一种类型的地址，
也不允许一种类型的引用指向另一种类型。
指向基类的引用和指针可以引用派生类的对象，不必进行显式类型转换。将派生类引用或指针转换为基类引用或指针被称为向上强制转换。
这使公有继承不需要进行显示类型转换，该规则是“is a”关系的一部分。
将基类指针或引用转换为派生类指针或引用被称为向下强制转换。如果不使用显式类型转换，则向下强制转换是不允许的。
原因是“is a”关系通常是不可逆的。
隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。

注意：如果要在派生类重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。

13.4.3有关虚函数注意事项
1.在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括从派生类派生出的类）中是虚的。
2.如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。
这称为动态联编，这样基类指针或引用可以指向派生类对象。
3.如果定义的类将被用作基类，测应将那些要在派生类中重新定义的类方法声明为虚的。

注意：
1.构造函数：构造函数不能是虚函数。
2.析构函数：析构函数应当是虚函数，除非类不用做基类。通常应给基类提供一个虚析构函数，即使它并不需要析构函数。
3.友元：友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。
4.没有重新定义：如果派生类没有重新定义函数，将使用该函数的基类版本。
5.重新定义将隐藏方法：

13.5访问控制：protected
protected与private相似，在类外只能用公有类成员来访问protected部分在的类成员。private和protected之间的区别只有在基类派生的类中才会表现出来。
派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。对于外部来说,保护成员的行为与私有成员相似；
对于派生类来说，保护成员的行为与公有成员相似。

13.6抽象基类
C++通过使用纯虚函数提供未实现的函数。纯虚函数声明的结尾为=0；当类声明中包含纯虚函数时，则不能创建该类的对象。
包含纯虚函数的类只能用作基类，要想成为真正的ABC，必须至少包含一个纯虚函数。原型中的=0使虚函数成为纯虚函数。
但任然可以在实现文件中提供方法的定义。总之：在原型中使用=0指出类是一个抽象基类，在类中不可以定义改函数。
ABC描述的是至少使用一个纯虚函数的接口，从ABC派生出的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。