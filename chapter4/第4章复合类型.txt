4.1数组
数组是一种数据格式，用来存储多个同类型的数据
声明数组的通用格式：
typeName arrayName[arraySize]
arraySize指定元素数目，必须是整型常数或者const常量或者常量表达式
如果将sizeof用于数组名，得到的是整个数组的字节数
4.1.3c++初始化数组
c++使用“{}”大括号进行数组初始化，首先，初始化时可以省略“=”等号；eg：int arrays[3] {1,2,3};
其次，可以在大括号内不包含任何东西，这将所有元素都设置为0；eg：int arrays[3] {};
第三，列表初始化禁止缩窄转换；eg: int age[] {25,24,22.0};//编译错误 char array[] {'a','b',97};//正确

4.2 字符串
字符串是存储在内存的连续字节的一系列字符，c++中处理字符串有两种方式:一种是c-风格字符串，另外一种基于String类库
c风格字符串：将字符串存储在char数组中，以空字符“\0”结尾.使用引号括起来的字符串来将字符数组初始化为字符串。这种字符串被称为字符串常量，用引号括起来的字符串隐式的包括结尾的空字符
在计算存储字符串所需字符数组的长度时，要将结尾的空字符包括在内。
strlen()函数返回存储在数组中的字符串长度，只计算可见字符，不会把空字符包含在内

4.2.4每次读取一行字符串输入
istream中的类（cin）提供了面向行的输入函数getline()和get()
面向行的输入：1.getline()
getline()函数读取整行，通过回车键输入的换行符来确定输入结尾，随后将会丢弃换行符，用空字符代替换行符。
getline()有两个参数：第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，剩余的空间用于存储自动在结尾添加的空字符
2.get()
读取到行尾时，将换行符保留在输入序列中，因此连续调用两次get()可能有问题。eg：
cin.get(name,arsize);
cin.get(name2,arsize);//有错，没有值
采用下面的方法：
cin.get(name,arsize);
cin.get();
cin.get(name2,arsize);
另外一种方式就是将两个函数连接使用，cin.get()的返回值也是cin对象
cin.get(name,arsize).get();
cin.get(name2,arsize).get();

3.空行或者其他问题
当get()读取到空行时将设置失效位，将阻断接下来的输入，可以用cin.clear()来恢复输入
当输入字符串大于分配的空间时，getline()和get()将多余的字符留着输入队列中，getline()将设置失效位，阻断后面的输入。

4.3 String类的简介
使用string类，必须包含string头文件，string类位于名称空间std中，必须使用using编译指令或者std::string

string对象和字符数组的相同点：
1、可以使用c-风格字符串来初始化string对象。
2、可以使用cin来将键盘输入存储到string对象中。
3、可以使用cout来显示string对象
4、可以使用数组表法来访问存储在string对象中的字符。

string对象和字符数组的区别：
可以将string对象声明为简单变量而不是数组，程序能够自动调整string的长度
不能将一个数组赋给另一个数组，但可以将一个string对象赋给另一个string对象

理论上可以将char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体

4.3.2赋值，拼接，附加
使用“+”将两个string对象拼接在一起

对于c-风格字符串可以使用C语言库中的函数来完成这些任务
strcpy(charr1,charr2);// 将charr2中的内容拷贝给charr1
strcat(charr1,charr2);//将charr2中的内容添加到charr1结尾

strlen()函数接收一个c-风格字符串作为参数，返回字符串包含的字符数
size()是string的类方法，返回字符串长度
eg:
string str;
getline(cin,str);//将键盘输入的值赋值给str

4.3.5其他形式的字符串字面值
c++11新增加的一种类型是原始(raw)字符串。在原始字符串中，字符就是表示的自身。
原始字符串使用"(和)"作为定界符，并使用前缀R来标识原始字符串。将输出（）内的所有内容。
eg:
cout<<R"("she" is a term not  she.\n)"
屏幕输出："she" is a term not  she.\n

注意：
在输入原始字符串时，按下回车键不仅会移动到下一行，还将在原始字符串中添加回车字符。
如果在原始字符串中包含)",编译器见到第一个)"会认为字符串结束，所以就必须自定义定界符。
自定义定界符：在默认定界符之间(引号和括号之间)添加任意数量的基本字符，但空格，左右括号，斜杠，控制字符除外。

4.4结构体简介
用关键字struct进行声明，在定义结构体变量的时候，c++可以省略struct关键字。
在c++中结构体初始化时，等号"="可以省略

4.4.5结构数组
结构体可以包含一个数组，也可以创建元素为结构体的数组。方法和基本类型数组一样

4.5共用体
用关键字“union”声明，能够存储不同的数据类型，但只能同时存储一种数据类型。共用体的长度是最大元素的长度。

4.6枚举
使用enum定义枚举
注意：
在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋给这种枚举变量。
对于枚举，只定义了赋值运算符，没有定义算术运算。
枚举量是整型，可以提升为int类型，但int类型不能自动转换为枚举类型。

4.7指针
在C语言中可以用malloc()来分配内存，在c++中仍可以这样做，但c++中更多的使用new运算符分配内存。
为一个数据对象获得并指定分配内存的通用格式：
typeName * pointer_name = new typeName;
eg：
int * p = new int;

new分配的内存块通常和常规变量声明分配的内存块不同，常规变量的值都存储在栈（stack）的内存区域中，
而new从堆（heap）或者自由存储区（free store）的内存区域分配内存。

4.7.5delete
当需要内存时用new分配内存，当使用完毕时用delete释放内存。
使用delete时，后面要加上指向内存块的指针（用new分配的）。
eg:
int * p  = new int;
delete p;

注意：
delete会释放指针所指向的内存，但不会删除指针本身，可以将指针重新指向另一个新分配的内存。
一定要配对使用new和delete，否则会发生内存泄露。
不要尝试释放已经释放的内存块。只能用delete来释放使用new分配的内存，然而对空指针使用delete是安全的。
不要创建两个指向同一内存块的指针，会增加错误删除同一内存块两次的可能性.
如果使用new[]为数组分配内存，则应使用delete[]来释放。

4.7.6用new创建动态数组
为数组分配内存的通用格式：
typeName * pointer_name  = new typeName[elements_num];
eg:
int *psome = new [10];
delete [] psome;
如果使用new[]为数组分配内存，则应使用delete[]来释放。

4.8.4使用new创建动态结构
使用箭头成员运算符（->）来访问结构体中的成员

4.8.5自动存储、静态存储、动态存储和线程存储
1.动态存储：在函数内部定义的常规变量使用自动存储空间，被称为自动变量（automatic variable）。
在所属函数被调用时自动产生，在函数结束时消亡。自动变量是一个局部变量，作用域为包含它的代码块。通常存储在栈中。

2.静态存储：在整个程序执行期间都存储的存储方式。
使得变量成为静态的方式：一种在函数外面定义它；另一种是在声明变量时使用关键字static。

3.动态存储
new和delete提供了动态存储，管理一个内存池。称为自由存储空间或堆。
该内存池同静态变量和自动变量的内存是分开的。数据的生命周期不完全受程序或函数的生存时间控制。

4.10数组的替代品
模板类vector和array是数组的替代品。

4.10.1模板类vector（矢量，向量）
vector类似于string类，是一种动态数组。是使用new创建动态数组的替代品，采用new和delete来管理内存。
使用vector：
首先包含头文件vector，其次vector包含在名称空间std中，第三模板使用不同的语法来指出存储的数据类型，第四vector类使用不同的语法来指定元素数。
通用做法：
vector<typeName> vt(n_elem);n_elem可以是整型常量，也可以是整型变量。

4.10.2模板类array（c++）
array位于名称空间std中，array对象的长度固定。
使用array：包含头文件array
array<typeName,n_elem> array;//创建一个名为array的array对象，包含n_elem个类型为typename的元素，n_elem不能是常量。

4.10.3三者比较
首先，无论数组，vector对象还是array对象，都可以使用标准数组表示法通过下标来访问各个元素。
其次，array对象和数组存储在相同的内存区域（栈）中，而vector对象存储在另一个区域（自由存储区或堆）。
第三，可以将一个array对象赋给另一个array对象；而对于数组，必须逐一复制。
数组越界：
在vector和array中能够禁止数组越界：使用成员函数at（n），将在运行期间捕获非法索引，而程序默认将中断。
begin（）和end（）能够确定边界，以免无意超界。








