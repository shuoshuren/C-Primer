第16章string类和标准模板库
16.1string类
“+=”：将字符串附加到字符串后面
“=”:将string对象，c-风格字符串或char值赋给string对象
“[]”:可以使用数组表示法来访问string对象中的各个字符。
“+”：将两个操作数合成一个string对象
16.1.2string类输入
对于c-风格字符串，有3中方式：
char info[100];
cin>>info;
cin.getline(info,100);
cin.get(info,100);

对于string对象，有两种方式：
string stuff;
cin>>stuff;
getline(cin,stuff);

16.1.3使用字符串
size()和length()：返回字符串的字符数；
find()：在字符串中搜索给定的子字符串或字符
rfind():查找子字符串或字符最后一次出现的位置
find_first_of():在字符串中查找参数中任何一个字符首次出现的位置
find_last_of():查找最后一次出现的位置
find_first_not_of():在字符串中查找第一个不包含在参数中字符
find_last_not_of();

capacity()返回当前分配给字符串的内存块的大小
reserve（）:返回请求内存块的最小长度。
c_str()方法返回一个指向c-风格字符串的指针，该c-风格字符串的内容与调用c_str()方法的string对象相同。

16.2智能指针模板类
智能指针是行为类似于指针的类对象
三个智能指针模板（auto_ptr,unique_ptr和shared_ptr）都定义了类似于指针的对象，可以将new获得的地址赋给这种对象，当智能指针过期时，其析构函数将使用delete来释放内存。
要创建智能指针对象，必须包含头文件memory.该文件模板定义，然后使用通常的模板语法来实例化所需类型的指针。
eg:
auto_ptr<double> pd(new double);
unique_ptr<double> pdu(new double);
shared_ptr<double> pss(new double);

16.2.2有关智能指针的注意事项
避免多个智能指针指向同一个对象，并且过期时删除多次：
1.定义复制运算符，使之执行深复制。这样两个指针将指向不同的对象，其中一个对象是另一个对象的副本。
2.建立所有权概念，对于特定的对象，智能有一个智能指针可以拥有它，只有拥有对象的智能指针的析构函数会删除该对象，然后，让赋值操作转让所有权。这就是用于auto_ptr和unique_ptr的策略，但unique_ptr的策略更严格。
3.创建智能更高的指针，跟踪引用特定对象的智能指针。称为引用计数。例如：赋值时，计数将加1，而指针过期时，计数将减一，仅当最后一个指针过期时，才调用delete。这是shared_ptr采用的策略
同样的策略适用于赋值构造函数。

C++有一个标准库函数std::move()，可以将unique_ptr赋给另一个。
注意：使用new分配内存时，才能使用auto_ptr和shared_ptr,使用new[]分配内存时，不能使用它们。不使用new分配内存时，不能使用auto_ptr或shared_ptr;不使用new或new[]分配内存时，不能使用unique_ptr.

16.2.4选择智能指针
如果程序要使用多个指向同一个对象的指针，应选择shared_ptr;
如果程序不需要多个指向同一个对象的指针，可使用unique_ptr;

16.3标准模板库
STL提供了一组表示容器，迭代器，函数对象和算法的模板。
容器是一个与数组类似的单元，可以存储若干个值，STL容器是同质的，即存储的值的类型相同
算法是完成特定任务（排序，查找）的方法
迭代器：能够用来遍历容器的对象，与能够遍历数组的指针类似，是广义指针
函数对象是类似于函数的对象，可以是类对象或函数指针（包括函数名）

16.3.1模板类vector
在计算机中，矢量（vector）对应数组。计算矢量存储了一组可随机访问的值。STL在头文件vector中定义了一个vector模板。
要创建vector模板对象，可使用通常的<type>表示法来指出要使用的类型，另外，vector模板使用动态内存分配，可以用初始化参数来指出需要多少矢量。
16.3.2对矢量可执行的操作
size（）：返回容器中元素数目
swap（）：交换两个容器的内容
begin():返回一个指向容器中第一个元素的迭代器
end():返回一个表示超过容器尾的迭代器。指向容器最后一个元素后面的那个元素。

迭代器的类是一个名为iterator的typedef，作用域为整个类
eg:vector<double>::iterator pd;//pd是一个迭代器。
push_back()：将元素添加到矢量末尾。将负责内存管理，增加矢量的长度，使之能够容纳新的成员。
erase():删除矢量中给定取决的元素。接收两个迭代器参数，第一个指向区间的起始处，第二个迭代器位于区间终止处的后一个位置。
insert()：插入元素，接收3个迭代器参数，第一个参数指定了新元素插入位置，第2个和第3个参数定义了被插入区间，该区间通常是另一个容器对象的一部分。
for_each():将被指向的函数应用于容器区间的各个元素，接收3个参数。前两个是定义容器中间去的迭代器，最后一个是指向函数的指针。被指向的函数不能修改容器元素的值，可以用for_each()代替for循环。
Random_shuffle()接收两个指定区间的迭代器参数，并随机排列该区间中的元素，该函数要求容器类允许随机访问
sort()函数也要求容器支持随机访问。该函数有两个版本：
1.接收两个定义区间的迭代器参数，并使用为存储在容器中的类型元素定义的<运算符，对区间中的元素进行操作。
2.接收三个参数，前两个参数指定区间的迭代器，最后一个参数指向要使用的函数的指针（函数对象），而不是用于比较的operator<()。返回值可转换为bool。

16.4泛型编程
STL是一种泛型编程（generic programming）。面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。
泛型编程旨在编写独立于数据类型的代码。在c++中，完成通用程序的工具是模板。模板使得能够按泛型定义函数或类，而STL通过通用算法更进一步。
16.4.1迭代器
模板使得算法独立于存储的数据类型，而迭代器使算法独立于使用的容器类型，他们都是STL通用方法的重要组成部分。
迭代器应具备的特征：
1.应能够对迭代器执行解除引用的操作，以便能够访问它引用的值，即如果p是一个迭代器，则应该对*p进行定义
2.应能够将一个迭代器赋给另一个。即如果p和q都是迭代器，则应对表达式p=q进行定义
3.应该能够将一个迭代器与另一个进行比较看它们是否相等。即如果p和q都是迭代器，则应对p==q和p!=q进行定义
4.应能够使用迭代器遍历容器中所有元素，这可以通过为迭代器p定义++p和p++来实现。

16.4.2迭代器类型
STL定义了5种迭代器，并根据所需的迭代器类型对算法进行了描述：输入迭代器，输出迭代器，正向迭代器，双向迭代器和随机访问迭代器。

1.输入迭代器
输入：从程序的角度来说，来自容器的信息被视为输入，输入迭代器可被程序用来读取容器中信息。对输入迭代器解除引用将使得程序能够读取容器中的值，但不一定能让程序修改值。
输入迭代器能够访问容器中的所有的值，这是通过支持++运算符来实现的。基于迭代器的任何算法都应当是单通行的，可以递增，但不能倒退。不依赖于前一次遍历时的迭代值，也不依赖于本次遍历中前面迭代器值。

2.输出迭代器
输出：将信息从程序传输给容器的迭代值。输出迭代器能够写，但不能读。

3.正向迭代器
正向迭代器只用++运算符来遍历容器，所以它每次沿容器向前移动一个元素，它总是按照相同的顺序来遍历一系列值，另外，将正向迭代器递增后，仍然可以对前面的迭代器值解除引用，并可以得到相同的值，使得多次通行算法成为可能。正向迭代既可以读取和修改数据，也可以只读取数据。

4.双向迭代器
双向迭代器具有正向迭代器的所有特性，同时支持两种“--”递减运算符。

5.随机访问迭代器
有些算法要求能够直接跳到容器中的任何一个元素，这叫做随机访问。随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于对元素进行排序的关系运算符。

16.4.4
1.
STL为输入输出提供了iterator模板，包含头文件iterator。
ostream_iterator<int,char> out_iter(cout,"");//ostream_iterator能够使用cout来显示信息，第一个模板参数指出被发送给数据流的数据类型；第二个模板参数指出了输出流使用的字符类型。构造函数的第一个参数指出要使用的输出流，最后一个字符串是在发送给输出流的每个数据项后显示的分隔符。
iterator头文件还定义了一个istream_iterator模板，使istream输入可用作迭代器接口
istream_iterator<int,char>(cin);//第一个参数指出要读取的数据类型，第二个参数指出输入流使用的字符类型，使用构造参数cin意味着使用有cin管理的输入流，省略参数代表输入失败，因此上述代码从输入流中读取，知道文件结尾，类型不匹配或出现其他输入故障为止。

2.其他有用的迭代器
头文件iterator还提供了其他一些专用的预定义迭代器类型：reverse_iterator,back_insert_iterator,front_insert_iterator和insert_iterator.

reverse_iterator:直线递增操作将导致它被递减。
back_insert_iterator:将元素插入到容器尾部。
front_insert_iterator:将元素插入到容器的前端。
insert_iterator:将元素插入到insert_iterator构造函数的参数指定的位置前面。

copy（）不仅可以将信息从一个容器复制到另一个容器，还可以将信息从容器复制到输出流，从输入流复制到容器中，还可以将信息插入到另一个容器中。

16.4.5容器种类
SRL具有容器概念和容器类。概念是具有名称的通用类别；容器类型是可用于创建具体容器对象的模板。
以前的11个容器类型：deque，list，queue。priority_queue，stack，vector，map，multimap，set，multiset和bitset，c++11新增forword_list, unordered_map, unordered_mulitmap,unordered_set和unordered_multiset，并且不将bitset视为容器，而将其视为一种独立的类别。
1.容器概念
概念描述了所用容器类都通用的元素，是一个概念化的抽象基类，容器概念指定了所用STL容器类都必须满足的一系列要求。
容器是存储其他对象的对象。被存储的对象必须是用一种类型，存储在容器中的数据为容器所有，当容器过期时，存储在容器中的数据也将过期。
不能将任何类型的对象存储在容器中，类型必须是可复制构造和可复制的。只要类定义没有将复制构造函数和赋值运算符声明为私有或保护的，则也满足这种要求。

复制构造和复制复制以及移动构造和移动复制的差别：复制操作保留源对象，而移动操作可修改源对象，还可以转让所有权，而不做任何复制。如果源对象是临时的，移动操作的效率将高于常规复制。

3.序列
7种STL容器类型d（deque，forword_list,list,queue,priority_queue,stack和vector）都是序列。序列概念增加了迭代器至少是正向迭代器的要求，报纸了元素将按照特定顺序排列，不会再两次迭代之间发生编码。array也被归类到序列容器。
序列还要求其元素按照严格的线性顺序排列，即存在第一个元素，最后一个元素，除此之外的每个元素前后都分别有一个元素。数组和链表都是序列，但分钟结构不是。
1.vector
vector模板在vector头文件中声明的，vector是数组的一种类表示，提供了自动内存管理功能，可以动态改变vector对象的长度，提供了对元素的随机访问。
除序列外，vector还是可反转容器概念的模型，这增加了两个类方法rbegin（）和end（），前者返回一个指向反转序列的第一个元素的迭代器，后者返回反转序列的超尾迭代器。
2.deque
deque模板类在头文件deque中声明，表示双端队列（double-ended queue），在STL中，其实现类似于vector容器，支持随机访问，区别在于，从deque对象的开始位置插入和删除元素的时间是固定的，而不像vector中是线性的。
3.list
list模板类是在头文件list中声明，表示双向链表。除了第一个和最后一个元素外，每个元素都与前后的元素向连接，这意味着可以双向遍历链表。list和vector的区别在于，list在链表任意位置进行插入和删除的时间都是固定的，因此，vector强调的是通过随机访问进行快速访问，而list强调的是元素的快速插入和删除。
list也是可反转容器，与vector不同的是，list不支持数组表示法和随机访问。
void merge（list<T,Alloc>&x）:将链表x与调用链表合并。两个链表必须已经排序，合并后的经过排序的链表保存在调用链表中，x为空
void remove（const T&val）：从链表中删除val的所有实例
void sort():使用<运算符对链表进行排序
void splice(iterator pos,list<T,Alloc>x):将链表x的内容插入到pos的前面，x将为空
void unique()：将连续相邻的相同元素压缩为单个元素。

6.forward_list(c++11)
c++11新增了容器类forward_list，实现了单链表。在这种链表中，每个节点都只连接到下一个节点，而没有连接到前一个节点，因此forward_list只需要正向迭代器，而不需要双向迭代器，forward_list是不可反转的容器。
7.queue
queue模板类在头文件queue中声明，是一个适配器类。queue模板让底层类（默认为deque）展示典型的队列接口。
bool empty()const:如果队列为空则返回true；否则为false
size_type size()const:返回队列中元素个数
T& front();返回指向队首元素的引用
T& back();返回指向队尾元素的引用
void push(const T& x);在队尾插入x
void pop（）删除队首元素。

8.priority_queue
priority_queue模板类在queue头文件中声明，是另一个适配器类，支持的操作与queue相同。主要区别在于：在priority_queue中，最大的元素被移到队首，内部区别在于，默认的底层类是vector。可以修改用于确定哪个元素放到队首的比较方式。
9.stack
stack在头文件stack中声明，也是一个适配器类，它给底层类（vector）提供了典型的栈接口
，将使用限制在定义栈的基本操作。
bool empty()const:如果栈为空则返回true；否则为false
size_type size()const:返回栈中元素个数
T& top();返回指向栈顶元素的引用
void push(const T& x);在栈顶插入x
void pop（）删除栈顶元素。
10array（c++11）
array模板在头文件array中定义的，并发STL容器。因为其长度固定，因此没有定义调整容器大小的操作。

16.4.4关联容器
关联容器是对容器概念的另一个改进。关联容器将值与键关联在一起，并使用键来查找值。
关联容器提供了对于元素的快速访问，也允许插入新元素，但不能指定元素的插入位置。原因在于关联容器通常有用于确定数据放置位置的算法，以便能够快速检索信息。
关联容器通常是使用某种树实现的。
STL提供了四种关联容器：set，multiset，map，multimap。头两种是在头文件set中定义的，后两种是在头文件map中定义的 。
set：值类型与键相同，键是唯一的，意味着集合中不会有多个相同的键，对于set来说，值就是键，multiset类似于set，只是可能有多个值的键相同。
map：值与键的类型不同，键是唯一的，每个键对于一个值，multimap与map类似，只是一个键可以与多个值相关联。

set容器的方法：
set_union(A.begin(),A.end(),B.begin(),B.end(),insert_iterator<set<string>>(C,C.begin()));//将A，B集合的并集存放到集合c中
set_intersection()和set_difference()分别查找交集和获得两个集合的差。
lower_bound():返回一个指向集合中第一个不小于键参数的成员的迭代器
upper_bound():返回一个指向集合中第一个大于键参数的成员的迭代器

multimap容器方法：
count（）接受键作为参数，返回具有该键的元素数目
lower_bound():返回一个指向集合中第一个不小于键参数的成员的迭代器
upper_bound():返回一个指向集合中第一个大于键参数的成员的迭代器
equal_range():用键作为参数，返回两个迭代器，表示的区间与该键匹配。

16.4.5无序关联容器（c++11）
无序关联容器将值与键关联起来，并使用键来查找值。底层区别在于：关联容器是基于树结构的，而无序关联容器是基于数据结构哈希表的，旨在提高添加和删除元素的速度已经提高查找算法的效率。
4种无序关联容器：unordered_set,unordered_multiset,unordered_map,unordered_multimap

16.5函数对象
STL算法都使用函数对象---也叫函数符（functor）。函数符是可以以函数方式与“()”结合使用的任意对象，包括函数名，指向函数的指针和重载了“()”运算符的类对象（即定义了函数operator()()的类）。
16.5.1函数符概念
函数符概念：
1.生成器是不用参数就可以调用的函数符
2.一元函数是用一个参数就可以调用的函数符
3.二元函数是用两个参数就可以调用的函数符。

头文件functional定义了多个模板类函数对象。其中包括plus<>();
可以使用plus<>类来完成常规的相加运算。

16.6算法
对于算法函数设计有两个主要的通用部分。首先都使模板来提供泛型；其次都使用迭代器来提供访问容器中数据的通用表示。
16.6.1算法组
STL将算法库分成4组：
1.非修改式序列操作：对区间中每个元素进行操作，这些操作不修改容器的内容，如find（）和for_each()
2.修改式序列操作：对区间中元素进行操作，可以修改值，也可以修改值的排列顺序。如transform(),random_shuffle()和copy()
3.排序和相关操作:包括多个排序操作和其他各种函数，包括集合操作
4.通用数字运算：将区间的内容累积，计算两个容器的内部乘积，计算小计，计算相邻对象差的函数。
前三组在头文件algorithm(以前叫algo.h)中描述，第4组是专用于数值数据的称为numeric(以前也位于algo.h中)

16.7其他库
头文件complex为复数提供了类模板complex，用于包含float，long，long double的具体化，这个类提供了标准的复数运算及能够处理复数的标准函数。
random提供了随机数功能
vector模板类是一个容器类和算法系统的一部分，支持面向容器的操作，如果排序，插入，搜索，将数据转移到其他容器中
valarray类模板时面向数值计算，不是STL的一部分，为很多数学运算提供了简单，直观的接口。
array表示长度固定的数组，是为替代内置数组而设计的，提供更好，更安全的接口，让数组更紧凑，效率更高

slice类：可用作数组索引，表示的是一组值。slice对象被初始化为3个整数值：起始索引，索引数，跨距。起始索引是第一个被选中的元素的索引，索引指出要选择多少个元素，跨距表示元素之间的间隔。

16.7.2模板initializer_list(C++11)
可使用初始化列表语法将STL容器初始化为一系列值。
要在代码中使用initializer_list对象，必须包含头文件initializer_list。该模板类包含成员函数begin()和end（）,size()返回元素数。
eg：std::initializer_list<double> d1 = {1.1,2.2,3.3,4.4};
可按值传递initializer_list对象，也可按照引用传递。

