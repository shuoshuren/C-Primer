第14章c++的代码重用
14.1包含对象成员的类
14.1.1valarray类简介
valarray类是有头文件Valarray支持的。这个类用于处理数组，支持诸如将数组中所有元素的值相加已经查找最值等操作。
valarray被定义为一个模板类，以便能够处理不同的数据类型。
模板特性意味着声明对象是，必须指定具体的数据类型。使用valarray类来声明一个对象时，需要在标识符valarray后面加上一对尖括号，
并在其中包含所需的数据类型。
eg：valarray<int> values;//int 数组。

可以创建长度为0的空数组，指定长度的空数组，所有元素被初始化为指定值的数组，用常规数组中的值进行初始化数组.

一些类方法：
operator[]();//访问各个元素
size():返回包含的元素个数
sum（）:返回所有元素的总和
max():返回最大的元素
min():返回最小的元素

接口和实现：
使用公有继承时，类可以继承接口，可能还有实现（基类的纯虚函数提供接口，但不提供实现）。获得接口是is-a关系的组成部分。
而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。

C++中的约束：使用explicit防止单参数构造函数的隐式转换，使用const限制方法修改数据

1.初始化被包含的对象：
构造函数能够使用成员初始化列表语法来初始化成员对象。对于继承的对象，构造函数在成员初始化列表中使用类名调用特定的基类构造函数。对于成员对象，构造函数则使用成员名。
初始化顺序：当初始化列表中包含多个项目时，这些项目被初始化的顺序为被声明的顺序，而不是他们在初始化类别中的顺序。

14.2私有继承
私有继承：使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。私有继承是has-a关系的一部分。
包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中，使用术语子对象（subobject）来表示通过继承或包含添加对象。
私有继承和包含一样：获得实现，但不获得接口。
私有继承在列出基类时使用关键字private。

14.2.1实例
使用多个基类的继承被称为多重继承（multiple inheritance，MI）.新的类不需要私有数据，因为基类已经提供了所需的所有数据成员。包含提供两个被显式命名的对象成员，而私有继承提供了两个无名称的子对象成员。
1.初始化基类组件
对于继承类，构造函数将使用成员初始化列表语法，使用类名而不是成员名来标识构造函数。
2.访问基类的方法
使用私有继承时，只能在派生类中使用基类的方法。私有继承使用类名和作用域解析运算符来调用基类的方法。总之，使用包含时将使用对象名来调用方法，使用私有继承时将使用类名和作用域解析符来调用方法
3.访问基类对象
通过使用强制类型转换将派生类对象转换为基类对象，来实现使用基类对象本身。
4.访问基类的友元函数
用类名显示的限定函数名不适合于友元函数，然而可以通过显式的转换为基类来调用正确的函数。

14.2.2使用包含时私有继承
通常，应使用包含来建立has-a关系；如果新类需要访问原有类的保护成员，或需要重新定义虚函数，则应该使用私有继承。

14.2.3保护继承
保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected。使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员，基类的接口在派生类中也是可用的，但在继承层次之外是不可用的。

14.2.4使用using重新定义访问权限
使用保护继承或私有继承时，如果要让基类的方法在派生类外面可以：
1.定义一个使用该基类方法的派生类方法。
2.将函数调用包装在另一个函数调用中，即使用using声明来指出派生类可以使用特点的基类成员，即使使用的是私有继承。using声明只适用于继承，而不适用于包含。

14.3多重继承
MI描述的是有多个直接基类的类。公有MI表示的也是is-a关系。
注意：必须使用关键字public来限定每一个基类。除非特别指出，否则编译器将认为是私有派生。私有MI和保护MI可以表示has-a关系。
c++引用多重继承的同时，引入了一种新技术-虚基类。

1.虚基类
虚基类使得从多个类（基类相同）派生出的对象只继承一个基类对象。通过在类声明中使用关键字virtual（virtual和public次序无关紧要）。
eg:
class Singer:virtual public Worker{};
class Waiter:public virtual Worker{};
class SigningWaiter:public Singer,public Waiter{};
警告：如果类有间接虚基类，则除非只需要使用该虚基类的默认构造函数，否则必须显式调用改虚基类的某个构造函数。

14.4类模板
模板类以下面这样的代码开头：
template<class Type>,较新的C++使用:template<typename Type>,可以使用自己的泛型名代替Type。
模板不是函数，不能单独编译。模板必须与特定的模板实例化请求一起使用。最简单的方法是将所有模板信息放到一个头文件中，并在要使用这些模板的文件中包含改头文件。

类模板的另一项新特性：可以为类型参数提供默认值：
eg:template<class T1,class T2=int>;

14.4.6模板的具体化
类模板与函数模板很相似，可以有隐式实例化，显式实例化和显式具体化。模板以泛型的方式描述类，而具体化是使用具体的类型生成类声明。
1.隐式实例化
声明一个或多个对象，指出所需的类型，而编译器使用通用模板提狗的处方生成具体的类定义，编译器在需要对象之前，不会生成类的隐式实例化。
2.显式实例化
当使用关键字template指出所需类型来声明类时，编译器将生成类声明的显式实例化。声明必须位于模板定义所在的名称空间中。
eg：template class ArrayTP<string,100>;
3.显式具体化
显式具体化是特定类型（用于替换模板中的泛型）的定义，有时可能需要在为特殊类型实例化时，对模板进行修改，使其行为不同。在这种情况下，可以创建显式具体化。
具体化类模板定义的格式如下：
template<> class Classname<specialized-type-name>{};
4.部分具体化
C++允许部分具体化，及部分限制模板的通用性。部分具体化可以给类型参数之一指定具体类型。

14.4.7成员模板
模板可用作结构、类或模板类的成员。

14.4.8将模板用作参数
模板可以包含类型参数（typename T）和非类型参数（int n）,模板可以包含本身就是模板的参数。
14.4.9模板类和友元
模板类声明也可以有友元。模板的友元分为3类：
非模板友元；
约束模板友元,即友元的类型取决于类被实例化时的类型；
非约束模板友元，即友元的所有具体化都是类的每一个具体化的友元。

14.4.10模板别名（c++11）
c++11新增一项功能-使用模板提供一系列别名。c++11允许将语法using用于非模板，用于非模板时，与常规typedef等价。
eg：template<typename T> using arrayType = std::array<T,12>;
这将arrayType定义为一个模板别名，可以用它来指定类型,arrayType<T> 代表类型std::array<T,12>：
eg:arrayType<double> gallons;


