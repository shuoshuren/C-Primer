9.内存模型和名称空间
9.1单独编译
头文件包含的内容：
函数声明
使用#define或const定义的符号常量
结构声明
类声明
模板声明
内联函数。

9.2存储持续性、作用域和链接性
1.自动变量：在函数定义中声明的变量，在程序开始执行其所属的函数或代码块是创建，在函数或代码块执行完毕后销毁。
2.静态变量：在函数定义外定义的变量和使用关键字static定义的变量在程序整个运行过程中都存在
3.线程存储变量：如果变量是使用thread_local声明的，则生命周期与所属的线程一样长
4.动态存储变量：用new分配的内存一直存在，直到使用delete将其是否或者程序结束位置。

9.2.1作用域和链接
作用域：描述了名称在文件的多大范围内可见。
链接新：描述了名称如何在不同单元间共享。

9.2.4
在全局变量中，c++提供了两种变量声明：一种是定义声明，它给变量分配存储空间，另一种是引用声明，它不给变量分配存储空间，只引用已有的变量。
引用声明使用关键字extern，且不进行初始化；否则声明为定义，导致分配存储空间。

9.2.10存储方案和动态分配
1.使用new初始化
如果要为内置的标量类型分配存储空间并初始化，可在类型名后面加上初始值，并将其用括号括起来。也适用于有构造函数的类
eg:int pi = new int(5);
如果要初始化常规结构体或数字，需要用大括号的列表初始化。在c++11中可以将列表初始化用于单值变量。
eg:
struct where{double x;double y;double z};
where one = new where{2.5,2.3,7.3};

4.定位new运算符
通常，new负责在堆（heap）中找到一个可以满足要求的内存块，而定位new运算符，它让你能够制定要使用的位置。
使用定位new特性，首先需要包含头文件new，提供了new运算符的原型；然后将new运算符用于提供所需地址的参数。除需要制定参数外，语法与常规new运算符相同。
eg：
char buffer[500];
int *p1 = new int;// place in heap
int * p2 = new (buffer) int; //place in buffer

9.3 名称空间
c++中通过定义一种新的声明区域来创建命名的名称空间，通过使用关键字namespace。
名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。

通过作用域解析运算符::来访问给定名称空间中的名称。
eg：std::cout

1.using声明和using编译指令
using声明使特定的标识符可用，using编译指令使整个名称空间可用
using声明由被限定的名称和它前面的关键字using组成：例如using std::cout;完成该声明后，便可以使用名称cout代替std::cout;
将using声明添加到函数内部，与其他局部变量一样，将覆盖同名的全局变量，使用::cout 可以使用全局变量。
将using声明添加到函数外部，将名称添加到全局名称空间中。

using编译指令使名称空间中所有的名称都可用。using编译指令由名称空间名和前面的关键字using namespace组成
eg：using namespace std；

3.名称空间的其他特性
可以将名称空间声明进行嵌套：
可以在名称空间中使用using编译指令和using声明。
可以给名称空间创建别名;
eg：namespace mvft = my_very_favorite_thing;

名称空间的指导原则：
1.使用在已命名的名称空间中声明的变量，而不是使用外部全局变量和静态全局变量
2.如果开发了一个函数库或类库，将其放到一个名称空间中。
3.仅将编译指令using作为将旧代码转换为使用名称空间的权宜之计。
4.不要在头文件中使用using编译指令，如果非要使用，应将其放到所有预处理指令#define之后。
5.导入名称时，首选使用作用域解析符或using声明的方法。
6.对于using声明，首选将作用域设置为局部而不是全局。





