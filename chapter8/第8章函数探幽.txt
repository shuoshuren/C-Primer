8函数探幽
8.1c++内联函数
使用内联函数必须采用以下措施之一：
在函数声明前加上关键字inline
在函数定义前加上关键字inline
通常做法是省略原型，将整个定义放到本应该提供原型的地方。但当函数过大或者函数调用的自己，编译器不将其作为内联函数。

inline是c++新增的特性，C语言使用预处理语句#define来提供宏--内联代码的原始实现，
如果使用C语言的宏执行了类似函数的功能，应该考虑将其转换为C++的内联函数。

8.2引用变量
c++新增了一种复合类型---应用变量，应用是已定义变量的别名
引用变量的主要用途是用作函数的新参，通过将应用变量用作参数，函数将使用原始数据，而不是副本。
8.2.1创建引用变量
c++中给“&”符号赋予另一个含义，将其用来声明应用
eg：
int rats;
int & rodents = rats;//int &指的是指向int的引用，rats和rodents指向相同的值和内存单元

引用于指针的区别：必须在声明引用时将其初始化，不能像指针一样，先声明，在赋值。引用更接近const指针.
可以通过初始化声明来设置引用，但不能通过赋值来设置。

8.2.2将引用用作函数参数
引用常用作函数参数，使得函数的变量名成为调用函数中的变量的别名，这种传递函数的方法称为按引用传递。
按引用传递允许被调用的函数能够访问调用函数中的变量。

如果实参与引用参数不匹配，c++将生成临时变量：
1.实参的类型正确，但不是左值
2.实参的类型不正确，但可以转换为正确的类型
左值：左值是可被引用的数据类型：变量，数组元素，结构体成员，指针都是左值，字面常量（用引号括起来的字符串除外）和包含多项的表达式是非左值。

将引用参数声明为const的理由：
1.使用const可以避免无意中修改数据的编程错误
2.使用const使函数能够处理const和非const实参，否则将只能接受非const数据。
3.使用const引用使函数能够正确生成并使用临时变量

c++中新增了另一种引用--右值引用，这种引用可指向右值，用&&声明。
右值引用的目的：让库设计人员能够提供有些操作的更有效的实现

ostream对象的格式化方法：
setf（）能够设置各种格式化状态
setf(ios_base::fixed);将对象置于定点表示法的模式
setf(ios_base::showpoint):将对象置于显示小数点的模式，即使小数部分为0.
precision();指定显示多少位小数（假定对象处于定点模式下）
以上所有设置都将保持不变，直到再次调用相应的方法重新设置他们。
width（）；设置下一次输出操作所使用的字段长度，只在显示下一个值时有效，然后恢复到默认设置。默认字段宽度为0，刚好能够容纳下要显示的内容。

使用引用参数的两个原因：
1.程序员能够修改调用函数的数据对象
2.通过传递引用而不是整个数据对象，可以提高程序的运行速度。

指导原则：
一、对于使用传递的值而不作修改的函数：
1.如果数据对象很小，按值传递
2.数据对象是数组，则使用指针，并将指针声明为指向const的指针。
3.数据对象是较大的结构，则使用const指针或const引用。
如果数据对象是类对象，则使用const引用。
二、对于修改调用函数中的数据的函数
1.如果数据对象是内置数据类型，则使用指针
2.数据对象是数组，只能使用指针
3.数据对象是结构，使用引用和指针
4.数据对象是类对象，则使用引用。

8.3默认参数
C++新增的默认参数指的是当函数调用中省略了实参时自动使用的一个值。
对于带参数列表的函数，必须从右向左添加默认值。实参按从左到右的顺序依次被赋给相应的形参，不能跳过任何参数。
只有原型指定了默认值，函数定义与没有默认参数时完全一样。
eg:int harpo(int n,int m=4,int j=5);//声明函数原型
int result = harpo(4);//使用
int result = harpo(4,5);//使用
int result = harpo(4,5,6);//使用

8.4函数重载
默认参数能让你使用不同数目的参数调用同一个函数，而函数多态（函数重载）能够让你使用多个同名函数。
函数重载的关键是函数的参数列表---函数特征标。如果两个函数的参数数目和类型相同，同时函数的排列顺序也相同，则他们的特征标相同，而变量名无关紧要。

注意：
1.没有匹配的原型并不会自动停止使用其中的某个函数，因为c++将尝试使用标准类型转换强制匹配。
2.编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。
3.匹配函数时，并不区分const和非const变量

8.5函数模板
函数模板使用泛型来定义函数，其中的泛型可用具体的类型替换，通过将类型作为参数传递给模板，可使编译器生成该类型的函数。
eg：
template<typename AnyType>或者template<class AnyType>
void swap(AnyType &a,AnyType &b){
	AynType temp;
	temp = a;
	a = b;
	b= temp;
}

显式模板函数：
eg：template <>  void Swap<int>(int &,int &);

8.5.6模板函数的发展
1.是什么类型
在编写模板函数时，一个问题是并非总能知道声明中使用哪种类型，c++11新增关键字decltype提供了解决方案。
通用格式：
decltype(expression) var;
eg:decltype(x+y) xpy = x+y;

核对表的简化版：
1.如果expression是一个没有用括号括起来的标识符，则var的类型与该标识符类型相同，包括const等限定符。
2.如果expression是一个函数调用，则var的类型与函数的返回值相同。
3.如果expression是一个左值，则var为指向其类型的引用。expression是用括号括起来的标识符。
4.如果前面的条件都不满足，则var的类型与expression的类型相同。
如果需要多次声明，则可以结合使用typedef和decltype。

3.c++11后置返回类型
double h(int x,float y);可写成这样auto h(int x,float y)->double;将返回类型移到参数声明后面，->double被称为后置返回类型，其中auto是一个占位符，表示后置返回类型提供的类型。可以借给decltype指定返回类型：
template<class T1,class T2>
auto gt(T1 x,T2 y) ->decltype(x+y){
	......
	return x+y;
}



