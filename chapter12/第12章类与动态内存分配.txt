12类与动态内存分配
12.1动态内存和类
12.1.2特殊成员函数
c++自动提供下面的这些成员函数：
1.默认构造函数，如果没有定义构造函数；
2.默认析构函数，如果没有定义；
3.复制构造函数，如果没有定义；
4.赋值运算符，如果没有定义；
5.地址运算符，如果没有定义；
c++提供另外两个特殊成员函数：移动构造函数和移动赋值运算符。

2.复制构造函数
复制构造函数用于将一个对象复制到新创建的对象中。通常用于初始化过程中。复制构造函数的原型：ClassName(const ClassName &);接收一个指向类对象的常量引用作为参数。
3.何时调用复制构造函数
当新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。
eg：假如motto是StringBad对象，下面四种声明都将调用复制构造函数：
StringBad ditto(motto);
StringBad metto = motto;
StringBad also = StringBad(motto);
StringBad * pStringBad = new StringBad(motto);
每当程序生成了对象副本时，编译器都将使用复制构造函数。当函数按值传递对象或函数返回对象时，都将使用复制构造函数。
4.默认的复制构造函数的功能
默认的复制构造函数逐个复制非静态成员，复制的是成员的值。

注意：
如果类中包含了使用new初始化的指针成员，应该定义一个辅助构造函数，以复制指向的数据，而不是指针，这被称为深度复制。
复制的另一种形式为复制指针值，浅复制仅复制指针信息。

12.1.4赋值运算符
c++中允许类对象赋值，是通过自动为类重载赋值运算符实现的。这种运算符的原型如下：
ClassName & ClassName::operator=(const ClassName &);
将已有的对象赋给另一个对象时，将使用重载的复制运算符。

复制运算符重载的实现的注意点：
1.由于目标对象可能引用了以前分配的数据，所以函数应该使用delete[]来释放这些数据。
2.函数应当避免将对象赋给自身；否则给对象重新复制前，释放内存炒作可能删除对象的内容。
3.函数返回一个指向调用对象的引用。

12.2改进后的新String类
在c++98中，0可以表示数字零，也可以表示空指针。NULL是表示空指针的C语言宏，c++11映入了关键字nullptr，用于表示空指针。

12.3构造函数中使用new时的注意事项:
1.如果在构造函数中使用new来初始化指针成员，则应该在析构函数中使用delete。
2.new和delete必须相互兼容。new对应delete，new[]对应delete[].
3.如果有多个构造函数，则必须以相同的方式使用new，所有的构造函数都必须与析构函数兼容。
可以在构造函数中使用new初始化或将指针初始化为空（0或者c++中nullptr）.
4.应当定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。还应该更新所有受影响的静态类成员。
5.应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象。操作：检查自我赋值的情况，释放成员指针以前指向的内存，
复制数据不仅仅是数据的地址，并返回一个指向调用对象的引用。

12.4有关返回对象的说明
12.4.1返回指向const对象的引用
使用const引用的常见原因是旨在提高效率。如果函数返回（通过调用对象方法或将对象作为参数）传递给它的对象，
可以通过返回引用来提高效率。返回对象将调用复制构造函数，而返回引用则不会。
12.4.2返回指向非const对象的引用
两种常见的返回非const对象情景是：重载赋值运算符以及重载与cout一起使用的<<运算符。前者旨在提高效率，后者必须这么做。
12.4.3返回对象
如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它。通常，被重载的算术运算符属于这一类.
12.4.4返回const对象
如果担心行为可能引发误用和滥用，一种简单的解决方法：将返回类型声明为const对象 。

12.5使用指向对象的指针
使用new初始化对象
如果Class_name是类，value的类型为Type_name,则下面的语句：
Class_name * pClass = new Class_name(value);
将调用如下的构造函数：
Class_name(Type_name);

Class_name *ptr = new Class_name;将调用默认构造函数；

12.5使用指向对象的指针
使用new初始化对象
如果Class_name是类，value的类型为Type_name,则下面的语句：
Class_name * pClass = new Class_name(value);
将调用如下的构造函数：
Class_name(Type_name);

Class_name *ptr = new Class_name;将调用默认构造函数；



12.7队列模拟
对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化。c++提供了一种特殊的语法来完成上述工作，
叫做成员初始化列表。成员初始化类别有逗号分隔的初始化列表组成（前面带冒号），位于参数列表的有括号之后，函数体左括号之前。
如果数据成员名称为mData，需要将其初始化为val,则初始化器为mData(val).

通常，初值可以为常量或构造函数的参数列表中的参数，这种方式并不限于初始化常量。只有构造函数可以使用这种初始化列表语法。
对于const类成员，必须使用这种语法。另外，对于被声明为引用的类成员，也必须使用这种语法。


