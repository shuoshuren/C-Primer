第18章 探讨C++新标准
18.1.3声明
1.auto
C++11将auto用于实现自动类型推断，要求显示初始化，让编译器能够将变量类型设置为初始值的类型，此外还可以简化模板声明。
2.decltype
关键字decltype将变量的类型声明为表达式指定的类型。在定义模板时特别有用，因为只有等到模板被实例化时才能确定类型。

3.返回类型后置
C++11新增了一种函数声明语法：在函数名和参数类别后面指定返回类型。可以使用decltype来指定模板函数的返回类型。
4.模板别名：using
对于冗长复杂的标识符，c++提供了typedef创建其别名，C++11提供了另一种创建别名的语法：using，新语法可以用于模板部分具体化，但typedef不能。
5.nullptr
C++在源代码中使用0表示空指针，c++11新增了关键字nullptr用来表示空指针；它时指针类型，不能转换为整型类型。

18.1.5异常规范
C++11摈弃了异常规范，新增了一个关键字noexcept，该关键字指出函数不会引发异常。

18.1.7对类的修改
1.显示转换运算符
c++引入关键字explicit，禁止单参数构造函数自动转换
6.尖括号
为避免与运算符>>混淆，C++要求在声明嵌套模板时使用空格将尖括号分开。

18.1.9右值引用
C++11新增了右值引用，使用&&表示，右值引用可关联到右值，即可出现在复制表达式右边，但不能对其引用地址运算符符值。右值包括字面常量（C-风格字符串除外），表达式以及返回值的函数（返回的不是引用）。

18.2移动语法和右值引用
移动语法：类似于在计算机中移动文件：实际原始数据仍还留在原来的地方，而只修改记录。
使用右值引用可支持移动语法。
移动语法的两个步骤：
1.右值引用让编译器知道何时可使用移动语法。
2.编写移动构造函数，使其提供所需的行为。
通过提供一个使用左值引用的构造函数和一个使用右值引用的构造函数，将初始化分成了两组。使用左值对象初始化对象时，将使用复制构造函数，使用右值对象初始化对象时，将使用移动构造函数。

18.3.2默认的方法和禁用的方法
使用关键字default显式的声明这些方法的默认版本；使用关键字delete可用于禁止编译器使用特定方法。
18.3.5管理虚方法：override和final
在c++11中，可使用虚说明符override指出要覆盖一个虚函数：将其放在参数类别后面。荣光声明与基类方法不匹配，编译器将视为错误。
禁止派生类覆盖特定的虚方法，可以使用说明符final，为此可在参数列表后面加上final

18.4 Lambda函数
lambda：来自Lambda calculus----一种定义和应用函数的数学系统，这个系统可以使用匿名函数（无需给函数命名），在C++11中，对于接受函数指针和函数符的函数，可使用匿名函数定义作为其参数。
区别：使用【】代替了函数名；没有声明返回类型，返回类型相当于使用decltype根据返回值推断得到。
仅当Lambda表达式完全有一条返回语句组成时，自动类型推断才管用；否则，需要使用新增的返回类型后置语法。

18.5包装器
C++提供了多个包装器（wrapper，也叫适配器[adapter]）,这些对象用于给其他编程接口提供更一致或更适合的接口。
C++11提供了其他的包装器：模板：bind,men_fn和reference_wrapper以及包装器function。
模板mem_fn能够将成员函数作为常规函数进行传递；
模板reference_wrapper能够创建行为像引用但可被复制的对象，
包装器function能够以统一的方式处理多种类似于函数的形式。
18.5.2
调用特征标：调用特征标是有返回类型以及用括号扩起来并用逗号分割的参数类型列表定义的。
模板function是在头文件functional中声明的，它从调用特征标的角度定义了一个对象；可用于包装调用特征标相同的函数指针，函数对象和Lambda表达式。

18.6可变参数模板
可变参数模板让你能够创建可接受可变数量的参数的模板函数和模板类
创建可变参数模板，有几个要点：
1.模板参数包（parameter pack）
2.函数参数包；
3.展开（unpack）参数包；
4.递归
18.6.1模板和函数参数包
C++11提供了一个用省略号表示的源运算符，能够让你声明表示模板参数包的标识符，模板参数包基本上是一个类型列表，同样还能够声明表示函数参数包的标识符，而函数参数包基本上是一个值列表。
语法如下：
template<typename.. Args>
void show_list(Args... args){}
Args是一个模板参数包，而args是一个函数参数包。Args和T的差别在于，T与一种类型匹配，而Args与任意数量的类型匹配。

18.6.3在可变参数模板函数中使用递归
将函数参数包展开，对列表中的第一项进行处理，再将剩下的内容传递给递归调用。以此类推，直到列表为空。
改进的形式：
template<typename T,typename... Args>
void show_list(T value,Args... args){}

18.7C++11新增的其他功能
18.7.1并行编程
C++定义了一个支持线程化执行的内存模型，添加了关键字thread_local，提供了相关的库支持。关键字thread_local将变量声明为静态存储，其持续性与特定线程相关：定义这种变量的线程过期时，变量也将过期。
库支持：有原子操作库和线程支持库组成。原子操作库提供了头文件atomic，线程支持库提供了头文件:thread,mutex,condition_variable和future。
18.7.2新增的库
头文件random支持的可扩展随机数库提供了大量的随机数工具
头文件chrono提供了处理时间间隔的途径
头文件tuple支持模板tuple，tuple对象是广义的pair对象。pair对象可存储两个类型不同的值，而tuple对象可存储任意多个类型不同的值
头文件ratio支持的编译极端有理数算术库能够准确表示任何有理数
头文件regex支持正则表达式库


end
2017/1/20 17:11


